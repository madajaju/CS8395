= What Problems Do Microservices Solve?
:icons: font
:customcss: ./custom.css
:revealjs_width: "100%"
:revealjs_height: "100%"

Video: https://youtu.be/oJzoxm6bV4Q


== What Problems Do Microservices Solve?

*Goals*

- Understand *which problems* microservices actually address
- Recognize when they are (and aren't) a good fit
- Be aware of key risks and tradeoffs

== Microservices in Context

Microservices are often treated as a default:

- "We need to scale → use microservices"
- "We have legacy code → rewrite as microservices"
- "Modern = microservices"

But they *add a lot of complexity*.

*Key idea*

[quote]
Microservices only make sense if they solve *specific problems you really have* +
better than simpler alternatives.

[.columns]
== Quick Definition

[.column]
--
A microservices architecture:

- System composed of *multiple small services*, each:
- Focused on a *single responsibility / capability*
- *Independently deployable* (own process/container)
- Often has its *own datastore or schema*
- Services communicate over the *network*:
- HTTP/REST, gRPC, messages, events
- Typically owned by *one team* ("you build it, you run it")

If services *can't* be changed and deployed independently, +
you may have a *distributed monolith*, not microservices.
--

[.column]
[plantuml, slide-2-quick-definition, svg]
----
@startuml
title Quick Definition of Microservices

rectangle "User Service" as UserSvc {
  rectangle "User API" as UserAPI
  rectangle "User Logic" as UserLogic
}
database "User DB" as UserDB

rectangle "Order Service" as OrderSvc {
  rectangle "Order API" as OrderAPI
  rectangle "Order Logic" as OrderLogic
}
database "Order DB" as OrderDB

rectangle "Billing Service" as BillingSvc {
  rectangle "Billing API" as BillAPI
  rectangle "Billing Logic" as BillLogic
}
database "Billing DB" as BillDB

UserAPI -down-> UserLogic
UserLogic -down-> UserDB

OrderAPI -down-> OrderLogic
OrderLogic -down-> OrderDB

BillAPI -down-> BillLogic
BillLogic -down-> BillDB

UserAPI -right-> OrderAPI : HTTP / gRPC / events
OrderAPI -right-> BillAPI : messages / events

actor "Team A" as TeamA
actor "Team B" as TeamB
actor "Team C" as TeamC

TeamA -down-> UserSvc
TeamB -down-> OrderSvc
TeamC -down-> BillingSvc

note bottom
  • Small, focused services
  • Independently deployable
  • Often own their own data
  • Typically 1 team per service
end note
@enduml
----

[.columns]
== Problem: Slow Delivery in a Huge Codebase

[.column]
--
*Symptoms*

- One large codebase; every change touches a lot of stuff
- Builds and tests are slow
- Merge conflicts and surprising side effects
- Unclear ownership: "Who owns this part?"

*Microservices help by*

- Splitting into *smaller, focused codebases*
- Giving teams *clear responsibility* per service
- Enabling *parallel development* without constant conflicts

*Note:* A well-structured *modular monolith* can also help here.
--
[.column]
[plantuml, slide-3-slow-delivery, svg]
----
@startuml
title Slow Delivery in a Huge Codebase

rectangle "Monolith" as Mono {
  rectangle "Huge Codebase\n(every feature touches this)" as BigCode
}
collections "Single Repo" as Repo
BigCode -down-> Repo

note right of Mono
  Symptoms:
  • Slow builds/tests
  • Frequent merge conflicts
  • Unclear ownership
end note

rectangle "After Splitting" as After {
  rectangle "User Service\n(small codebase)" as USvc
  rectangle "Orders Service\n(small codebase)" as OSvc
  rectangle "Billing Service\n(small codebase)" as BSvc
}

USvc -down-> "User Repo"
OSvc -down-> "Orders Repo"
BSvc -down-> "Billing Repo"

note right of After
  Benefits:
  • Smaller focused repos
  • Clearer ownership
  • Parallel development
end note
@enduml
----

== Problem: Coupled Release Cycles
*Symptoms*

- Shipping a feature needs *multiple teams* and a *full system release*
- Release trains, change freezes, and high coordination cost
- One unstable component delays *everyone*

*Microservices help by*

- Allowing *independent deployments* per service
- Letting teams ship on *their own schedule*
- Enabling *small, frequent, safer releases*

*Precondition*

- Backward-compatible APIs and sane versioning—otherwise independence is fake.

[.columns]
== Problem: Uneven Scaling & Poor Isolation

[.column]
--
*Scaling symptoms*

- Some parts are "hot" (e.g., search, checkout), others "cold" (admin, reports)
- Monolith forces you to *scale everything together*

*Isolation symptoms*

- One bug or slowdown can bring down the entire app
- Hard to degrade gracefully (e.g., hide recommendations but keep ordering)
--
[.column]
--
*Microservices help by*

- Letting you *scale services independently*
- Providing *process-level isolation*
- Supporting graceful degradation with timeouts, retries, fallbacks

*Caveat*

- Without good resilience patterns, failures can still *cascade*.
--

== Uneven Scaling
[plantuml, slide-5-uneven-scaling, svg]
----
@startuml
title Uneven Scaling & Isolation

rectangle "Monolith" as Mono {
  rectangle "Search" as MSearch
  rectangle "Checkout" as MCheckout
  rectangle "Admin" as MAdmin
}

node "App Server\n(x N)" as MonoServers
MonoServers -down-> Mono

note left of Mono
  Hot: Search, Checkout
  Cold: Admin
  But you scale everything together.
end note

rectangle "Microservices" as Micro {
  rectangle "Search Service" as SSearch
  rectangle "Checkout Service" as SCheckout
  rectangle "Admin Service" as SAdmin
}

node "Search Cluster\n(x 8)" as SearchCluster
node "Checkout Cluster\n(x 6)" as CheckoutCluster
node "Admin Cluster\n(x 1)" as AdminCluster

SearchCluster -down-> SSearch
CheckoutCluster -down-> SCheckout
AdminCluster -down-> SAdmin

note right of Micro
  Scale hot paths more,
  cold paths less. +
  Process isolation allows
  partial degradation.
end note
@enduml
----

[.columns]
== Problem: Tech & Schema Lock-In

[.column]
--
*Symptoms*

- One language/framework/DB for everything
- Changing tech stack is a massive, risky migration
- Different parts of the system have *different needs*, but share one stack

*Microservices help by*

- Allowing *polyglot architectures* (within guardrails)
- Letting you modernize *incrementally*, service by service
- Matching storage/tech to *service needs* (e.g., relational vs document vs search)

Too much tech diversity, though, increases cognitive and ops load.
--
[.column]
[plantuml, slide-6-tech-lockin, svg]
----
@startuml
title Tech & Schema Lock-In

left to right direction

rectangle "Monolith Stack" as Mono {
  rectangle "Java / Spring" as J
  database "Single Relational DB\n(shared schema)" as RDB
}

J -down-> RDB

note right of Mono
  One tech stack and schema
  for all use cases.
end note

rectangle "Microservices Stack" as Micro {
  rectangle "User Service\n(Java/Spring)" as US
  database "User DB\n(relational)" as UDB

  rectangle "Orders Service\n(Kotlin)" as OS
  database "Orders DB\n(relational)" as ODB

  rectangle "Search Service\n(Node.js)" as SS
  database "Search Index\n(e.g. Elasticsearch)" as SDB
}

US -down-> UDB
OS -down-> ODB
SS -down-> SDB

note right of Micro
  Polyglot services and storage
  (within guardrails) +
  allow incremental modernization.
end note
@enduml
----

[.columns]
== Problem: Misaligned Boundaries & Teams
[.column]
--
*Symptoms*

- Teams constantly collide in the same code areas
- Ownership is fuzzy; blame and coordination overhead are high
- Org structure and system structure don't line up

*Microservices help by*

- Aligning services to *business capabilities* and *teams*
- e.g., `payments-service`, `catalog-service`, `orders-service`
- Giving each team *clear ownership* and autonomy

You can get some of this with a *modular monolith* if you enforce boundaries and ownership.
--

[.column]
[plantuml, slide-7-misaligned-boundaries, svg]
----
@startuml
title Misaligned Boundaries & Teams

left to right direction
' Misaligned: teams share same blob
rectangle "Monolith Module" as Blob {
  rectangle "Payments Code" as Pay
  rectangle "Catalog Code" as Cat
  rectangle "Orders Code" as Ord
}

actor "Team A" as TA
actor "Team B" as TB
actor "Team C" as TC

TA -down-> Blob
TB -down-> Blob
TC -down-> Blob

note right of Blob
  Teams collide in the same code,
  ownership is fuzzy.
end note

' Aligned with microservices
rectangle "Microservices" as Micro {
  rectangle "Payments Service" as PaySvc
  rectangle "Catalog Service" as CatSvc
  rectangle "Orders Service" as OrdSvc
}

actor "Payments Team" as PayTeam
actor "Catalog Team" as CatTeam
actor "Orders Team" as OrdTeam

PayTeam -down-> PaySvc
CatTeam -down-> CatSvc
OrdTeam -down-> OrdSvc

note right of Micro
  Clear ownership:
  one team per capability.
end note
@enduml
----


== What Microservices Do *Not* Magically Fix

Microservices do *not* automatically solve:

- Bad domain modeling or unclear requirements
- Poor engineering practices (tests, reviews, communication)
- Performance problems from bad algorithms or queries
- Lack of observability (they actually demand *more* of it)
- Organizational dysfunction or misaligned incentives

They *amplify* both good and bad practices.

== Costs & Preconditions

*Preconditions for benefits*

- System and team size justify the split
- Reasonably stable domain boundaries
- Operational maturity:
- CI/CD, monitoring, tracing, on-call, config/secrets management

*Costs introduced*

- More operational complexity (deployments, configs, failure modes)
- Distributed systems issues (timeouts, retries, partial failures)
- Data consistency challenges (no easy cross-service ACID)
- Harder testing and debugging across services

== Summary

Microservices *do* help with:

- Large, tangled codebases and slow delivery
- Coupled release cycles and coordination overhead
- Uneven scaling and need for better isolation
- Tech/schema lock-in across an entire system
- Misalignment between system and team boundaries

But:

[quote]
Use microservices *because they solve concrete problems you have*, +
and you're ready to pay the complexity cost— +
not just because "everyone else is doing it."