1
00:00:01,166 --> 00:00:01,600
Okay.

2
00:00:01,600 --> 00:00:04,666
In this lecture
we're going to cover OAuth and Oidc

3
00:00:05,066 --> 00:00:08,066
and what they are,
how they build on top of each other

4
00:00:08,266 --> 00:00:11,733
and how to use them and and look at all

5
00:00:11,733 --> 00:00:15,266
the risks and tradeoffs
in, using these in your design.

6
00:00:16,033 --> 00:00:18,966
So the key thing
that we want to understand here

7
00:00:18,966 --> 00:00:23,466
is that why we would need a loss
and oidc in the first place?

8
00:00:24,533 --> 00:00:26,833
A lot of times I've got server to server

9
00:00:26,833 --> 00:00:29,833
interactions that need to carry with them

10
00:00:30,400 --> 00:00:32,100
user information.

11
00:00:32,100 --> 00:00:35,333
And specifically you let the user log in

12
00:00:36,266 --> 00:00:40,066
and then the backend
has to act on behalf of that user.

13
00:00:40,533 --> 00:00:44,766
And so I need some way of delegating
that access across the back end,

14
00:00:45,700 --> 00:00:49,633
which becomes really important
as the number of microservices increase.

15
00:00:49,900 --> 00:00:53,433
You don't want just blanket microservices
accessing whatever,

16
00:00:54,000 --> 00:00:57,100
there needs to be context in scope
a lot of times, and a lot of times

17
00:00:57,100 --> 00:01:02,500
our scope is tied to the user
that's, logged in, that needs

18
00:01:02,500 --> 00:01:06,500
specific information and things like that
without a standard there.

19
00:01:06,500 --> 00:01:10,633
Then what we end up having is passwords
that are shared across multiple apps.

20
00:01:11,000 --> 00:01:14,866
Or each app rolls its own login session
model.

21
00:01:15,166 --> 00:01:17,333
It's hard to centralize a bunch of it.

22
00:01:17,333 --> 00:01:20,600
So coming up with a common way of,

23
00:01:20,600 --> 00:01:24,333
authorizing and identifying is
is really important.

24
00:01:24,333 --> 00:01:28,133
And that's what OAuth two and Oidc does.

25
00:01:28,533 --> 00:01:33,266
So first off, Oauth2 is a framework
for delegated authorization.

26
00:01:33,266 --> 00:01:36,766
So application X can call application

27
00:01:37,000 --> 00:01:40,533
or API y for user Z.

28
00:01:41,233 --> 00:01:43,433
Within the scope that it's gotten.

29
00:01:43,433 --> 00:01:47,000
So it defines roles, tokens,
grant types, things like that.

30
00:01:47,533 --> 00:01:50,533
It does not define identity.

31
00:01:50,600 --> 00:01:55,033
It just identifies,
the roles, the tokens, the grant type.

32
00:01:55,200 --> 00:01:58,466
So open a OpenID connect

33
00:01:59,100 --> 00:02:01,633
sits on top of OAuth two.

34
00:02:01,633 --> 00:02:07,000
And it shows you who the user is
and where they login from.

35
00:02:07,000 --> 00:02:09,033
So it gives more identity.

36
00:02:09,033 --> 00:02:12,300
It adds ID tokens,
user informations and discovery.

37
00:02:12,800 --> 00:02:15,866
So it extends OAuth 2.0.

38
00:02:15,866 --> 00:02:19,800
So think of OAuth 2.0
is kind of the framework.

39
00:02:20,066 --> 00:02:23,533
And OpenID connect has more data

40
00:02:23,533 --> 00:02:26,533
enriched data on top of that framework.

41
00:02:26,700 --> 00:02:29,833
So that's the easiest way
to to think about the two.

42
00:02:31,200 --> 00:02:34,966
So core roles
in OAuth two I've got a resource owner.

43
00:02:34,966 --> 00:02:38,166
So someone that owns
some data on the back end.

44
00:02:38,166 --> 00:02:38,500
Right.

45
00:02:38,500 --> 00:02:43,566
I've got a client that's an app that's
requesting access to the user's data.

46
00:02:43,566 --> 00:02:45,633
They're back in data through.

47
00:02:45,633 --> 00:02:46,866
And it could be a web app.

48
00:02:46,866 --> 00:02:51,333
It could be a single page application,
a mobile, another service.

49
00:02:51,333 --> 00:02:52,833
Whatever the case may be,

50
00:02:52,833 --> 00:02:56,600
they don't have an authorization server
that authenticates the user.

51
00:02:57,033 --> 00:02:59,466
It issues tokens to the client.

52
00:02:59,466 --> 00:03:02,466
It handles
what we normally see with authorization.

53
00:03:02,600 --> 00:03:04,200
Do I have a resource server?

54
00:03:04,200 --> 00:03:06,766
It's an API hosted protected server.

55
00:03:06,766 --> 00:03:10,200
Resources on the back
end, it validates the tokens

56
00:03:10,200 --> 00:03:13,200
and enforces authorization.

57
00:03:14,733 --> 00:03:18,333
So real easy
a resource owner will talk to a client.

58
00:03:18,333 --> 00:03:21,333
It's using the app in the client,
whatever the case may be.

59
00:03:21,933 --> 00:03:25,433
And it wants to access something
on the resource server

60
00:03:25,433 --> 00:03:29,400
on the back end before it does
that it goes to the authorization server.

61
00:03:29,900 --> 00:03:35,500
And then I get a callback,
to the, resource

62
00:03:35,866 --> 00:03:39,666
owner that says you need to authenticate
and consent access to this.

63
00:03:40,466 --> 00:03:40,733
Right.

64
00:03:40,733 --> 00:03:44,800
And then it will do that,
and then it will put

65
00:03:44,800 --> 00:03:48,233
that token back into the request
back in the client.

66
00:03:48,866 --> 00:03:52,066
And then it now has access to to it.

67
00:03:52,400 --> 00:03:57,333
And you're going to see
if you've ever done a OAuth to workflow,

68
00:03:57,600 --> 00:04:01,533
the kind of a little bit of a pain
because the client itself

69
00:04:01,833 --> 00:04:05,500
has to have a callback, so that it can,

70
00:04:05,866 --> 00:04:11,166
it gets tokens back that then it can
then create access tokens,

71
00:04:11,500 --> 00:04:15,066
based off of the ID, so it adds that,

72
00:04:15,133 --> 00:04:18,200
extra layer in into setting things up.

73
00:04:18,633 --> 00:04:20,000
It's a little bit of a pain at first,

74
00:04:20,000 --> 00:04:21,800
but once you get it running,
it works really well.

75
00:04:23,066 --> 00:04:24,800
So tokens, we've talked about

76
00:04:24,800 --> 00:04:28,233
tokens in other lectures,
but real quick I've got access tokens.

77
00:04:28,700 --> 00:04:31,400
They're used for calling the APIs

78
00:04:31,400 --> 00:04:34,400
and they contain
the reference in the scope

79
00:04:34,533 --> 00:04:37,666
and the
I everything that you need in order

80
00:04:38,000 --> 00:04:41,033
to, let that client do something

81
00:04:41,033 --> 00:04:44,033
specifically on behalf of the user.

82
00:04:44,100 --> 00:04:49,066
I refresh token is a long lived token
that's kept in the client,

83
00:04:49,966 --> 00:04:53,833
and it's used to get access to new access
tokens.

84
00:04:54,366 --> 00:04:59,433
The new access tokens are generated
when a user comes in.

85
00:04:59,600 --> 00:05:02,500
I take that long live, refresh token.

86
00:05:02,500 --> 00:05:06,866
I pass in the ID to the, OAuth server.

87
00:05:07,300 --> 00:05:12,033
The observer then creates a new access
token for that user and that client.

88
00:05:12,400 --> 00:05:14,433
Right. It's never sent.

89
00:05:14,433 --> 00:05:18,733
The access token is not set or
the refresh token is not sent to the APIs.

90
00:05:19,033 --> 00:05:21,333
Only the access token is right.

91
00:05:21,333 --> 00:05:26,766
And then the ID token for
oh idk, this is a JWT

92
00:05:27,166 --> 00:05:30,066
that's set up about the user, right?

93
00:05:30,066 --> 00:05:35,500
So so it has the username
maybe authentication time,

94
00:05:35,966 --> 00:05:38,166
ID and things like that.

95
00:05:38,166 --> 00:05:42,166
So this is, this sits on top of that,
OAuth

96
00:05:42,166 --> 00:05:46,233
two layer to provide a more standard
way of identifying the user.

97
00:05:48,166 --> 00:05:48,633
Okay.

98
00:05:48,633 --> 00:05:51,633
So what OAuth two is it's a framework.

99
00:05:51,633 --> 00:05:57,066
And then and an authorization flow that
contains roles token types and grants.

100
00:05:57,166 --> 00:06:01,633
It does not define the token formats JWT

101
00:06:01,633 --> 00:06:05,266
with with OpenID connect really
does that part.

102
00:06:06,100 --> 00:06:10,666
It does not define how a user
authentication is implemented just yet.

103
00:06:10,666 --> 00:06:16,000
They have been authenticated and 
how the identity identity is represented.

104
00:06:16,033 --> 00:06:18,300
It's not part of the last two hours.

105
00:06:18,300 --> 00:06:21,733
Two is all about authorization, not about,

106
00:06:22,333 --> 00:06:25,333
authentication or ID.

107
00:06:25,566 --> 00:06:28,566
We see that in open ID,

108
00:06:29,933 --> 00:06:31,766
and connect.

109
00:06:31,766 --> 00:06:34,766
And that's really where you're going
to see ID claims discovery

110
00:06:34,766 --> 00:06:37,766
and user information.

111
00:06:38,233 --> 00:06:41,833
Common grant types
that we see are authorization code

112
00:06:41,833 --> 00:06:45,566
plus a PKI, for browser
based and native apps.

113
00:06:45,566 --> 00:06:49,966
The user gets redirected
to an author authorization server.

114
00:06:50,533 --> 00:06:55,133
They say, yes, I am going to allow someone
to work on my behalf.

115
00:06:55,533 --> 00:06:59,800
The client then exchanges their,
code for access token,

116
00:07:00,300 --> 00:07:01,833
as I've already mentioned.

117
00:07:01,833 --> 00:07:07,000
And then, it's a
just a modern way of of securing those,

118
00:07:09,166 --> 00:07:10,333
Securing those

119
00:07:10,333 --> 00:07:14,700
interactions on those back end
APIs to, act

120
00:07:14,700 --> 00:07:18,933
on the behalf of a user, 
a client, a specific client.

121
00:07:18,933 --> 00:07:22,233
Right. Different types of credentials
here.

122
00:07:22,233 --> 00:07:24,633
I could do machine to machine credentials.

123
00:07:24,633 --> 00:07:30,500
A client can, authenticate itself
to an, authentication server,

124
00:07:30,700 --> 00:07:35,833
and then it gets that access
token has the client identity, right?

125
00:07:36,366 --> 00:07:39,366
And that client identity includes

126
00:07:40,133 --> 00:07:41,533
the user. Right?

127
00:07:41,533 --> 00:07:46,600
If it's machine to me machine,
it will just return the client identity

128
00:07:46,866 --> 00:07:50,566
and the identity of that, 
possibly that device,

129
00:07:50,566 --> 00:07:53,566
if you want to go that far.

130
00:07:54,200 --> 00:07:54,566
Right.

131
00:07:54,566 --> 00:07:57,100
So why do we need OpenID?

132
00:07:57,100 --> 00:07:59,900
Connect or Oidc?

133
00:07:59,900 --> 00:08:04,233
Because, Oauth2 focuses on authorization.

134
00:08:05,233 --> 00:08:08,100
It doesn't focus on who's logged in,

135
00:08:08,100 --> 00:08:11,500
and, standard way of identifying that.

136
00:08:11,500 --> 00:08:16,000
So that's where open ID see shines.

137
00:08:16,000 --> 00:08:16,233
Right.

138
00:08:16,233 --> 00:08:20,466
It reuses the flows of OAuth two
and it has ID tokens.

139
00:08:20,466 --> 00:08:22,566
User information discovery.

140
00:08:22,566 --> 00:08:25,266
Any other kind
of metadata that's out there.

141
00:08:26,566 --> 00:08:27,566
Okay.

142
00:08:27,566 --> 00:08:31,233
So I've got an ID token and an access
token.

143
00:08:31,500 --> 00:08:34,200
ID token is for client application.

144
00:08:34,200 --> 00:08:36,433
Who the user is
when they're authenticated,

145
00:08:36,433 --> 00:08:38,600
when they drop all that stuff.

146
00:08:38,600 --> 00:08:43,466
And it's used to establish user sessions
so that the primary sits in the client.

147
00:08:43,766 --> 00:08:46,866
The access token
also can sit in the client as well,

148
00:08:47,033 --> 00:08:50,433
but is for calling back
end APIs and resource servers,

149
00:08:50,733 --> 00:08:54,933
and it grants access to those resources
within the certain scopes.

150
00:08:55,266 --> 00:08:59,400
And with, for that user
that you've already been identified.

151
00:09:01,333 --> 00:09:04,000
So this is how the exchange works.

152
00:09:04,000 --> 00:09:06,733
So I've got a user that says, hey,

153
00:09:06,733 --> 00:09:09,933
I want to access this app with no session.

154
00:09:10,366 --> 00:09:14,966
The client app will then, log
into the authorization, server.

155
00:09:15,566 --> 00:09:19,833
It will pass back to the user saying,
hey, I need you to log in

156
00:09:20,600 --> 00:09:24,633
and consent that this client application
can work on your behalf.

157
00:09:24,966 --> 00:09:28,533
So the user then goes, okay, I'm
going to let you do that.

158
00:09:29,366 --> 00:09:31,266
And then it redirects.

159
00:09:31,266 --> 00:09:34,233
So the the user gets

160
00:09:34,233 --> 00:09:38,100
that, that callback, once it does that,
it will

161
00:09:38,100 --> 00:09:42,033
then exchange the token
with the authorization server

162
00:09:42,633 --> 00:09:46,366
and the, credentials
that were passed in by the user.

163
00:09:46,700 --> 00:09:51,200
And it creates a local session
in the client from the ID token.

164
00:09:51,400 --> 00:09:53,900
Typically,
the access token will be in there.

165
00:09:53,900 --> 00:09:59,733
And now the client can now call
the backend server on behalf of that user.

166
00:09:59,866 --> 00:10:04,966
Because I've already created that access
token for that user with the proper scope

167
00:10:05,433 --> 00:10:09,000
on what data can access
and what operations that can perform.

168
00:10:12,866 --> 00:10:15,166
So it's important here that you understand

169
00:10:15,166 --> 00:10:18,833
that we have architectural separation
between the authorization server.

170
00:10:19,166 --> 00:10:22,300
That gives me a central way of authorizing

171
00:10:22,533 --> 00:10:26,066
against multiple clients
and multiple backends, servers.

172
00:10:26,533 --> 00:10:27,100
Right.

173
00:10:27,100 --> 00:10:31,266
Your client, app
does not handle passwords or the directory

174
00:10:31,433 --> 00:10:36,266
that's handled by the authorization server
or the authentication, gets called

175
00:10:36,266 --> 00:10:39,266
and then the authorization server
says, yes, they've been authenticated.

176
00:10:39,566 --> 00:10:42,233
So your client apps doesn't handle that
at all.

177
00:10:42,233 --> 00:10:46,300
It just consumes the ID tokens
and manages sessions in that case.

178
00:10:46,566 --> 00:10:50,133
And then the back end resources,
they validate the access tokens,

179
00:10:50,633 --> 00:10:53,200
by by asking the authorization

180
00:10:53,200 --> 00:10:56,333
server, hey, I got this access
token is a valid.

181
00:10:56,333 --> 00:10:57,700
The answer is yes, it's valid.

182
00:10:57,700 --> 00:11:00,133
And this is what you're allowed to do.

183
00:11:00,133 --> 00:11:04,300
Then your resource server will
will enforce the scopes and permissions

184
00:11:04,300 --> 00:11:05,066
on the back end.

185
00:11:06,566 --> 00:11:07,333
Okay.

186
00:11:07,333 --> 00:11:09,766
When when does this pattern fit?

187
00:11:09,766 --> 00:11:15,933
Well, when I have multiple apps and API
needing that single sign on concept.

188
00:11:16,633 --> 00:11:19,533
Let's say I have several backend services

189
00:11:19,533 --> 00:11:22,100
that might be calling
third party services.

190
00:11:22,100 --> 00:11:23,800
You're going to see a lot of third party
services.

191
00:11:23,800 --> 00:11:28,100
You use OAuth two, 
especially if you're limiting

192
00:11:28,466 --> 00:11:31,466
the kind of data
that they're accessing on the back end.

193
00:11:31,833 --> 00:11:35,466
If I want consistent token validation
across all my microservices,

194
00:11:35,666 --> 00:11:38,666
this is a really good pattern
to use, right?

195
00:11:38,866 --> 00:11:43,666
And also, if you can avoid handling
passwords directly in any,

196
00:11:43,666 --> 00:11:48,033
native or single page applications,
that's a good way to go.

197
00:11:48,333 --> 00:11:51,233
Let the authorization service, handle

198
00:11:51,233 --> 00:11:54,233
that for you.

199
00:11:54,400 --> 00:11:57,400
When do you want to move with something
simple?

200
00:11:57,433 --> 00:12:01,500
If I have a simple app
with no external calls and seeing

201
00:12:01,533 --> 00:12:06,233
limited scope, then is simple username,
password and session might be okay.

202
00:12:06,700 --> 00:12:09,433
Internal only like non

203
00:12:09,433 --> 00:12:12,800
user workflows,
API keys work pretty well for that.

204
00:12:13,400 --> 00:12:17,433
But if you have user workflows
where a specific user

205
00:12:17,433 --> 00:12:20,600
needs to be valid, then you should will
certainly do a swath right.

206
00:12:21,033 --> 00:12:26,900
But also if you get this under control
and you using maybe a third party,

207
00:12:27,300 --> 00:12:31,266
OAuth framework that's already there
and you start with this,

208
00:12:31,266 --> 00:12:36,633
then it's not a pain to integrate it
later, which it can be a major pain

209
00:12:36,966 --> 00:12:41,533
if you do this, post facto here, it will
require a lot of reworking of your code.

210
00:12:43,866 --> 00:12:46,233
Okay, here's some risk and complexity.

211
00:12:46,233 --> 00:12:48,733
It's powerful, but it can be complex.

212
00:12:48,733 --> 00:12:52,666
So you can do indirect, incorrectly.

213
00:12:52,666 --> 00:12:54,900
You could set up your scopes wrong.

214
00:12:54,900 --> 00:12:58,000
You can have token leaks,

215
00:12:58,000 --> 00:13:02,300
if you're storing those in the URL itself,
like in the query

216
00:13:02,733 --> 00:13:06,166
parameters or logs
or even in the front end.

217
00:13:06,166 --> 00:13:10,233
So sometimes, you can skip validation

218
00:13:11,033 --> 00:13:14,800
if, you do it wrong and you don't want
those sorts of things right.

219
00:13:15,100 --> 00:13:18,466
So use some of the vetted libraries
that are already out there.

220
00:13:18,466 --> 00:13:20,766
There's great ones for almost every, 
language.

221
00:13:20,766 --> 00:13:22,200
It's out there.

222
00:13:22,200 --> 00:13:25,900
Avoid any legacy flows like OAuth.

223
00:13:26,600 --> 00:13:29,666
You need to look at OAuth two,
not just author OAuth.

224
00:13:30,266 --> 00:13:32,666
And and set those up.

225
00:13:32,666 --> 00:13:35,533
Always validate the signature,

226
00:13:35,533 --> 00:13:39,333
when you're grabbing,
those, requests that are coming in.

227
00:13:41,233 --> 00:13:41,866
Okay.

228
00:13:41,866 --> 00:13:45,166
Another important thing is token lifetime
and revocation,

229
00:13:45,833 --> 00:13:48,466
short lived tokens.

230
00:13:48,466 --> 00:13:51,100
I have a lower impact
if things are stolen.

231
00:13:51,100 --> 00:13:51,333
Right.

232
00:13:51,333 --> 00:13:53,433
But they require
the refresh in the report.

233
00:13:53,433 --> 00:13:57,033
So if you have a two short
like five minutes, you're going to be

234
00:13:57,333 --> 00:13:58,966
reporting all the time.

235
00:13:58,966 --> 00:14:01,166
If you do like 30 minutes,

236
00:14:01,166 --> 00:14:04,733
I see a lot of external APIs
doing like a 30 minute ripoff.

237
00:14:05,300 --> 00:14:08,433
That seems to be a sweet spot
for a lot longer live ones.

238
00:14:08,433 --> 00:14:12,500
There's fewer round trips,
but if someone gets your, token

239
00:14:12,933 --> 00:14:16,700
and they can go to town for a longer
amount of time, that's the only downside.

240
00:14:17,166 --> 00:14:20,166
And then if you're going to go
full blown JWT,

241
00:14:20,733 --> 00:14:23,833
they're harder to revoke
because they, you know,

242
00:14:24,333 --> 00:14:27,333
they, they move around, and

243
00:14:27,433 --> 00:14:31,733
you probably want to have shorter
lifetimes and increase

244
00:14:31,733 --> 00:14:35,700
the refresh tokens, 
the number of times that you refresh. So.

245
00:14:37,833 --> 00:14:38,533
All right.

246
00:14:38,533 --> 00:14:39,933
Front channel versus back channel.

247
00:14:39,933 --> 00:14:43,966
So important front channel
is that client that the user is getting

248
00:14:43,966 --> 00:14:47,000
in, is getting in.

249
00:14:47,000 --> 00:14:49,933
That client
is acting on behalf of that user.

250
00:14:49,933 --> 00:14:54,366
So when you setting things up,
you'll get some browser redirects and URLs

251
00:14:54,366 --> 00:14:57,666
and career parameters
that are going to come in,

252
00:14:59,800 --> 00:15:03,000
to the user browser
when they authenticate things,

253
00:15:03,133 --> 00:15:07,333
the back channel is primarily
handled to server to server calls.

254
00:15:07,633 --> 00:15:10,633
It's safe
for tokens and secrets on on the back end.

255
00:15:10,666 --> 00:15:14,933
So on the front channel, use
very short lived codes.

256
00:15:15,633 --> 00:15:18,800
On the back channel you can use
a little bit longer codes right.

257
00:15:19,600 --> 00:15:22,466
So that those are some tips. There.

258
00:15:22,466 --> 00:15:24,733
We talked about sessions.

259
00:15:24,733 --> 00:15:27,733
You can store tokens in your sessions.

260
00:15:27,933 --> 00:15:31,533
And in fact Oidc supplies
an identity token

261
00:15:31,533 --> 00:15:35,133
that you can easily store
in your session on the browser.

262
00:15:35,400 --> 00:15:41,966
Just be mindful
of cookies and Csrf, attacks.

263
00:15:41,966 --> 00:15:47,566
So make sure that you, check out
the lecture on Csrf and how to avoid them.

264
00:15:48,066 --> 00:15:52,200
And then, so just make sure that you're
handling, that all appropriately

265
00:15:52,766 --> 00:15:56,166
and make sure you're handling your er,
contracts, appropriately.

266
00:15:56,466 --> 00:16:01,633
If they're not authorized to do something,
you must throw the appropriate, error

267
00:16:02,000 --> 00:16:06,033
in, in there and make sure that you're
handling that appropriately

268
00:16:06,366 --> 00:16:10,166
so that you can give the client the,
the appropriate information,

269
00:16:10,166 --> 00:16:13,166
because if they're not authorized to work
something on the back end,

270
00:16:13,433 --> 00:16:16,333
then that's important
for the client to know that.

271
00:16:16,333 --> 00:16:20,000
So it doesn't just keep retrying,
things over and over again.

272
00:16:21,466 --> 00:16:22,366
Okay.

273
00:16:22,366 --> 00:16:25,666
That's that's really it on OAuth two.

274
00:16:26,000 --> 00:16:27,800
Like I said,
there's lots of libraries out there.

275
00:16:27,800 --> 00:16:29,266
There's lots of great materials.

276
00:16:29,266 --> 00:16:31,033
On how to set these up.

277
00:16:31,033 --> 00:16:34,000
There can be a little difficult
at first to understand,

278
00:16:34,000 --> 00:16:35,533
but once you get your head
wrapped around it

279
00:16:35,533 --> 00:16:39,033
there, it's a very powerful,
architectural design pattern.
