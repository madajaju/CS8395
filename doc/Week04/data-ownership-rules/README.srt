1
00:00:00,300 --> 00:00:00,633
Okay.

2
00:00:00,633 --> 00:00:01,200
This lecture we're

3
00:00:01,200 --> 00:00:05,300
going to talk about data ownership rules
that you should be using microservices.

4
00:00:05,700 --> 00:00:08,933
As we've mentioned in earlier, lectures,

5
00:00:09,266 --> 00:00:13,900
that I have two microservices
with high cohesion and low coupling.

6
00:00:14,300 --> 00:00:16,600
We should have a database per service.

7
00:00:16,600 --> 00:00:19,466
Most of the time you can do this,
but not all the time.

8
00:00:19,466 --> 00:00:22,100
So we're going to talk about
some different strategies here.

9
00:00:22,100 --> 00:00:26,100
But the goal is that through microservices

10
00:00:26,100 --> 00:00:29,100
each must have its own data.

11
00:00:29,400 --> 00:00:29,766
All right.

12
00:00:29,766 --> 00:00:33,166
And in this lecture we're going
to explain why that's the case.

13
00:00:33,166 --> 00:00:38,133
Identified problems with shared databases
and discuss cross boundary access

14
00:00:38,433 --> 00:00:43,000
and handle a referential integrity
where I've got some data that's in my one

15
00:00:43,000 --> 00:00:46,166
microservice that is referencing data
in another microservice.

16
00:00:46,166 --> 00:00:47,900
And how do I handle that appropriately?

17
00:00:49,133 --> 00:00:50,366
So first off,

18
00:00:50,366 --> 00:00:54,600
a service must, have its data private.

19
00:00:54,866 --> 00:00:58,200
This is this goes back to object
oriented analysis and design,

20
00:00:58,400 --> 00:01:03,200
where you only access the data of a class
in through its interface.

21
00:01:03,200 --> 00:01:07,166
Now, this same concept exists here
with microservices.

22
00:01:07,166 --> 00:01:11,466
I should only be accessing
the private data of that microservice

23
00:01:12,666 --> 00:01:15,133
through the Rest interface,

24
00:01:15,133 --> 00:01:18,066
not through database calls
or anything like that.

25
00:01:18,066 --> 00:01:19,666
That's internal.

26
00:01:19,666 --> 00:01:21,766
And those internal details

27
00:01:21,766 --> 00:01:25,700
have to stay internal,
not through, direct public interface.

28
00:01:25,766 --> 00:01:28,866
So if all you did was write update table

29
00:01:29,100 --> 00:01:33,066
in your microservice,
then you're doing the wrong thing, right?

30
00:01:33,100 --> 00:01:36,633
You need to make sure
that you have your access layer

31
00:01:36,633 --> 00:01:40,333
that's there, and make sure that you have
the appropriate abstractions there.

32
00:01:40,333 --> 00:01:44,233
So if you do change your database
on the back end, not every single

33
00:01:44,233 --> 00:01:48,000
other microservice that depends on
you is going to, have a problem.

34
00:01:49,266 --> 00:01:52,266
So why don't we do shared databases?

35
00:01:52,533 --> 00:01:55,333
Because it,

36
00:01:55,333 --> 00:01:57,566
it, it should be public enemy number one.

37
00:01:57,566 --> 00:01:58,666
First off.

38
00:01:58,666 --> 00:02:01,366
And we don't want these shared databases
because you have

39
00:02:01,366 --> 00:02:04,933
schema lock in, which means I'm
locked into a schema that can't change

40
00:02:04,933 --> 00:02:09,300
or one change in service
A will break service B

41
00:02:09,900 --> 00:02:13,166
and or any other service
that access that service, say.

42
00:02:13,833 --> 00:02:15,866
So that could be a problem.

43
00:02:15,866 --> 00:02:21,466
Performance could be, an issue,
especially if I have service

44
00:02:21,466 --> 00:02:26,500
B accessing the same database, a service a
and service B is pretty chatty,

45
00:02:26,766 --> 00:02:30,300
then it could actually interfere
that called the noisy neighbor

46
00:02:30,733 --> 00:02:33,866
with, extra queries
that it really doesn't need to do.

47
00:02:34,300 --> 00:02:37,033
If it was going
through the appropriate interface

48
00:02:37,033 --> 00:02:41,066
on service A so performance is an issue.

49
00:02:41,066 --> 00:02:43,366
And then last is security.

50
00:02:43,366 --> 00:02:47,533
If you want to do least privilege,
then all of that access

51
00:02:47,533 --> 00:02:51,333
and authorization controls should be
handled through the microservice.

52
00:02:51,333 --> 00:02:52,566
Right.

53
00:02:52,566 --> 00:02:54,600
The authorization
comes into the microservice.

54
00:02:54,600 --> 00:02:55,666
The access is there.

55
00:02:55,666 --> 00:02:59,900
And I know what part of my interface
I can access instead of

56
00:02:59,900 --> 00:03:03,800
accessing the database directly,
or instead of pushing

57
00:03:03,800 --> 00:03:07,766
all of that access to the database
into another database server,

58
00:03:08,600 --> 00:03:13,000
all you've done is uncreated coupling,
which we know coupling is bad.

59
00:03:14,533 --> 00:03:17,533
So what about foreign data?

60
00:03:17,600 --> 00:03:19,533
Now this is a great example.

61
00:03:19,533 --> 00:03:23,333
This is like on my podcast that I do
I've got episodes

62
00:03:23,866 --> 00:03:27,166
episode is pretty well contained,
but an episode

63
00:03:27,166 --> 00:03:30,966
belongs to a podcast,
while podcast has a lot of other data.

64
00:03:30,966 --> 00:03:34,700
So I have a podcast microservice
and I have an episode microservice,

65
00:03:35,000 --> 00:03:40,033
but the episode needs to know
which podcast it belongs to, right?

66
00:03:40,033 --> 00:03:44,700
So in this option, I can say, hey,
if I need to know more information

67
00:03:44,700 --> 00:03:49,500
about the podcast, I can use an API call
or service A or my episode.

68
00:03:50,033 --> 00:03:54,500
Microservice is going to call service B
and say,

69
00:03:54,900 --> 00:03:58,800
here's a key to my podcast

70
00:03:59,300 --> 00:04:03,300
that I belong to, podcast ID and I need,

71
00:04:03,600 --> 00:04:06,600
who the author is or who the,

72
00:04:07,266 --> 00:04:10,066
who the host is of the show, right?

73
00:04:10,066 --> 00:04:11,100
I don't know why I need that.

74
00:04:11,100 --> 00:04:14,266
Maybe I need that for when I'm generating
show notes or something.

75
00:04:14,700 --> 00:04:18,000
I want the host name and
maybe the guest of the show or whatever.

76
00:04:18,000 --> 00:04:22,800
So I'm going to go ask with the ID, I'm
going to go ask, hey, here's the episode.

77
00:04:22,800 --> 00:04:25,200
I need the host name for that.

78
00:04:25,200 --> 00:04:29,366
So that's one way of getting that foreign
data into that out of the microservice.

79
00:04:29,700 --> 00:04:31,433
I'm not accessing the data directly.

80
00:04:31,433 --> 00:04:33,866
I'm going through the API.

81
00:04:33,866 --> 00:04:36,600
Another option is called replication.

82
00:04:36,600 --> 00:04:40,133
This is where a service b
if an event happens, service B

83
00:04:40,133 --> 00:04:44,100
will publish an event
that will be out on an event bus

84
00:04:44,366 --> 00:04:48,366
and service
A will save that into a local projection.

85
00:04:48,866 --> 00:04:51,866
It's almost like a cache
you can think of in some respects.

86
00:04:52,533 --> 00:04:57,033
If I don't if if I need that guest name, 
or the host name quite a bit.

87
00:04:57,466 --> 00:05:00,300
I don't want to keep hitting service A

88
00:05:00,300 --> 00:05:03,366
or my podcast service constantly. Right.

89
00:05:03,366 --> 00:05:05,300
So I can bring that in.

90
00:05:05,300 --> 00:05:08,166
I can save it in a local projection,

91
00:05:08,166 --> 00:05:11,166
but there's some downsides to this, right?

92
00:05:13,000 --> 00:05:14,233
There's temporal

93
00:05:14,233 --> 00:05:18,566
coupling that, could happen,
were lots of plus.

94
00:05:18,566 --> 00:05:18,766
Right.

95
00:05:18,766 --> 00:05:22,800
Because I don't have to hit them,
but I can at the con

96
00:05:22,800 --> 00:05:27,166
is that if the host changes,
if it goes from Darren

97
00:05:27,166 --> 00:05:30,166
Pulsifer
to Doctor Darren Pulsifer, for example.

98
00:05:30,633 --> 00:05:35,066
Then all of a sudden,
I have, inconsistencies in my data

99
00:05:35,400 --> 00:05:39,166
in the episode server or, 
service B in this case.

100
00:05:39,400 --> 00:05:44,766
So you gotta you gotta, look at the pros
and cons of each of these options

101
00:05:44,766 --> 00:05:49,033
so that you have now referential integrity
is is really important.

102
00:05:49,566 --> 00:05:55,066
This is where I have foreign keys
that I can access across.

103
00:05:55,333 --> 00:05:57,366
It's typically in database systems.

104
00:05:57,366 --> 00:06:01,833
I have a, foreign key in a table, right,
that says, hey,

105
00:06:02,233 --> 00:06:08,000
this, relationship of this element,
there's a row in my table,

106
00:06:08,500 --> 00:06:11,900
refers to this row in another table.

107
00:06:12,033 --> 00:06:12,900
Right.

108
00:06:12,900 --> 00:06:17,666
And so they use foreign keys or IDs
that, integrity

109
00:06:17,666 --> 00:06:21,733
on these, on these foreign keys
is the responsibility of the application,

110
00:06:22,900 --> 00:06:23,966
itself.

111
00:06:23,966 --> 00:06:24,300
Right.

112
00:06:24,300 --> 00:06:28,400
So you have to someone
still has to own those foreign keys,

113
00:06:28,700 --> 00:06:30,200
make sure that they're correct.

114
00:06:30,200 --> 00:06:33,133
And you need to use logic
to handle any deletes

115
00:06:33,133 --> 00:06:35,833
or accept partial inconsistency

116
00:06:35,833 --> 00:06:39,100
throughout your, your architecture.

117
00:06:39,300 --> 00:06:42,133
So you got
you got to understand these, foreign

118
00:06:42,133 --> 00:06:45,133
keys, your IDs, make sure that you're
handling them appropriately.

119
00:06:46,433 --> 00:06:48,266
Let's talk about, a real world

120
00:06:48,266 --> 00:06:51,466
example of the Netflix title
metadata service.

121
00:06:51,466 --> 00:06:54,466
So I've got a metadata service
that owns the titles

122
00:06:54,466 --> 00:06:57,466
and the descriptions
of all the movies on Netflix.

123
00:06:58,066 --> 00:06:58,633
Right.

124
00:06:58,633 --> 00:07:03,833
Then I have a playback service, and a
playback service needs the title to show.

125
00:07:03,833 --> 00:07:05,966
Now, playing,

126
00:07:05,966 --> 00:07:08,733
you know, one of the Marvel movies, right.

127
00:07:08,733 --> 00:07:11,200
Doomsday that's coming up. Right.

128
00:07:11,200 --> 00:07:14,533
And then so what Netflix does is
what they do

129
00:07:14,533 --> 00:07:18,033
is they have a playback service
that caches its own metadata

130
00:07:19,233 --> 00:07:22,633
instead of
constantly hitting the metadata service.

131
00:07:22,633 --> 00:07:28,033
So when you first started up, the playback
service now caches that title.

132
00:07:28,600 --> 00:07:31,500
And this works really well

133
00:07:31,500 --> 00:07:35,400
because the Metis,
the metadata service crashes.

134
00:07:35,400 --> 00:07:37,233
I can still watch my movie.

135
00:07:37,233 --> 00:07:42,033
So I've kind of decoupled,
that dependency, this doesn't work.

136
00:07:42,033 --> 00:07:48,000
Well, if the data is changing a lot
and that you're, asking for, like,

137
00:07:48,000 --> 00:07:51,933
if the metadata on, 
the titles and descriptions changed a lot,

138
00:07:52,766 --> 00:07:57,033
then I could have a lot of inconsistency
of data in my architecture.

139
00:07:57,533 --> 00:08:02,533
But if I'm grabbing it once and caching
it, this is a good way of decoupling,

140
00:08:03,033 --> 00:08:07,033
deployment, decoupling, 
which can be a problem, right.

141
00:08:07,033 --> 00:08:09,800
Especially if you've got
a lot of these services

142
00:08:09,800 --> 00:08:12,833
and you have a lot of interdependencies
between microservices.

143
00:08:13,500 --> 00:08:18,833
So there's metadata
caching is a is a good, method to use

144
00:08:20,000 --> 00:08:20,833
in most

145
00:08:20,833 --> 00:08:25,166
situations, depending on
how often that data is changing.

146
00:08:25,166 --> 00:08:28,166
If it's changing a lot,
this could be a detrimental.

147
00:08:29,833 --> 00:08:30,133
Okay.

148
00:08:30,133 --> 00:08:33,333
So when you guys are working on assignment
one A,

149
00:08:33,966 --> 00:08:36,333
you should I need you to diagram

150
00:08:36,333 --> 00:08:40,933
in your architectures
what services have what data

151
00:08:40,933 --> 00:08:43,933
and what your dedicated,
DV is going to be.

152
00:08:43,933 --> 00:08:45,766
It can be a relational database.

153
00:08:45,766 --> 00:08:48,533
It could be a, document database.

154
00:08:48,533 --> 00:08:50,533
It could be a file system for all I care.

155
00:08:50,533 --> 00:08:55,366
I just need to see that you are, 
isolating the data

156
00:08:55,366 --> 00:08:58,766
and the data can only be, accessed
through the microservice.

157
00:08:59,100 --> 00:09:02,100
And then I don't have two microservices
accessing the same data.

158
00:09:02,800 --> 00:09:05,233
If you have that,

159
00:09:05,233 --> 00:09:08,333
then you didn't create a microservice
architecture.

160
00:09:08,333 --> 00:09:10,200
You created a distributed monolith.

161
00:09:10,200 --> 00:09:12,733
So be more be mindful of that.

162
00:09:12,733 --> 00:09:17,100
Also, I want you to document
how you're handling foreign IDs

163
00:09:17,700 --> 00:09:20,900
like the user ID and your schema
or whatever the case may be, right?

164
00:09:21,300 --> 00:09:24,000
You need to say this is a foreign key.

165
00:09:24,000 --> 00:09:26,666
I decided to do, replication.

166
00:09:26,666 --> 00:09:29,300
I decided to do the API call.

167
00:09:29,300 --> 00:09:30,900
And why did you decide to do that?

168
00:09:30,900 --> 00:09:35,133
So these are important things that
you have to decide for your architecture.

169
00:09:36,400 --> 00:09:36,733
All right.

170
00:09:36,733 --> 00:09:40,933
So in summary data,
ownership is foundational

171
00:09:41,133 --> 00:09:44,900
to autonomy, which is one of the key
elements of a microservice architecture.

172
00:09:45,400 --> 00:09:49,766
It helps you enforce strict boundaries
of the data layer and services.

173
00:09:50,100 --> 00:09:52,500
I should not be accessing.

174
00:09:52,500 --> 00:09:55,400
Underlying data microservices directly,

175
00:09:55,400 --> 00:09:59,100
which means that if you do this right,
your schemas can change.

176
00:09:59,100 --> 00:10:03,800
You can enrich your metadata
on your schemas inside your microservices

177
00:10:04,100 --> 00:10:06,800
without having any effect applied.
