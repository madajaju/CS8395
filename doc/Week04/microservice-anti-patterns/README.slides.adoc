= Microservice Anti-Patterns
:revnumber: 1.0
:revealjs_theme: black
:revealjs_transition: slide
:revealjs_slideNumber: true
:revealjs_history: true

== Introduction
Adopting microservices is easy to get wrong. 

* **Goal:** Identify common mistakes and "wrong turns."
* **Strategy:** Learn to recognize symptoms and course-correct.

[.columns]
== Outcomes
[.column]
* Define common anti-patterns.
* Recognize symptoms.

[.column]
* Discuss fixes.
* Understand the complexity cost.

== 1. The Distributed Monolith

[plantuml, distributed-monolith, svg]
----
@startuml
skinparam componentStyle uml2
skinparam packageStyle rect

package "The Deployment Train" {
  [Service A] as A
  [Service B] as B
  [Service C] as C
  A -right-> B
  B -right-> C
  C -left-> A
}

note top of A : Must deploy A, B, and C\nat the same time
note bottom of B : Failure in B\ncascades to all
@enduml
----

* **Symptom:** Tight coupling requires all services to deploy together.
* **Failure:** One service failing crashes the entire system.
* **Fix:** Stable API contracts, circuit breakers, and Database per Service.

== 2. Nano-services
* **Symptom:** Slicing so thin that tiny logic pieces are separate services.
* **Problem:** Network overhead outweighs business value.
* **Fix:** Merge services sharing the same context or reason for change.

== 3. Shared Database
* **Symptom:** Multiple services read/write to the same tables.
* **Problem:** Changing a column requires updating multiple codebases.
* **Fix:** Assign a single "Owner" service; others use its API.

== 4. Mega-Gateway

[plantuml, mega-gateway, svg]
----
@startuml
skinparam componentStyle uml2

actor Client
component "Mega-Gateway" <<Bottleneck>> as GW
component "Service A" as A
component "Service B" as B

Client -down-> GW
GW -down-> A
GW -down-> B

note right of GW
  <b>Logic inside Gateway:</b>
  * Auth / RBAC
  * Data Transformation
  * Request Aggregation
  * A/B Testing Logic
end note
@enduml
----

* **Symptom:** All business logic lives in the API Gateway (NGINX/Kong).
* **Problem:** Gateway becomes a bottleneck and a monolith.
* **Fix:** Keep the gateway "dumb" (routing/SSL/rate limiting only).

== 5. Ignoring Observability
* **Symptom:** You must log into 5 servers to debug one request.
* **Fix:** Centralized logging (ELK) and Distributed Tracing (Jaeger) from day one.

== 6. Real-World: The Knight Capital Glitch
* **The Error:** A $440M loss in 45 minutes.
* **The Cause:** 1 of 8 servers wasn't updated correctly (Zombie Code).
* **The Lesson:** Deployment coupling and lack of observability can be fatal.

== 7. Tie-in: Assignment A1
* **Shared DB Trap:** Ensure your two implementations (e.g., Go and Java) do **not** share a database.
* **Logging:** Use structured logging to ensure your service is "observable" from the start.

== 8. Summary
* Microservices add complexity.
* Wrong boundaries = worst of both worlds (monolith rigidity + distributed complexity).
* Stay vigilant for these patterns as you grow.
