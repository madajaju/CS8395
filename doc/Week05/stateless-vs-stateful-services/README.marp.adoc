= Stateless vs Stateful Services
:revnumber: 1.0
:revealjs_theme: black
:revealjs_transition: slide
:revealjs_slideNumber: true
:revealjs_history: true

:revealjs_width: "100%"
:revealjs_height: "100%"

Video: https://youtu.be/x8lQrDvzWQY

== 1. Motivation: Why State Matters

Every system needs to remember something:

- Who is logged in
- What items are in a cart
- Where a workflow is in its lifecycle

The architectural question is **where that memory lives**. This choice affects:

- Scalability
- Reliability
- Deployment strategy
- Cost

[.columns]
== 2. Core Definitions

[.column]
--
**Stateless service**
- Does not retain client-specific data between requests.
- Each request contains all information needed to process it.


**Stateful service**
- Retains data or context across requests.
- Requests depend on prior interaction or local stored state.

In practice, most systems include both, but the distribution of state is a major design decision.
--

[.column]
--
[plantuml, format=svg, width=100%]
....
@startuml
title Core Definitions
left to right direction
rectangle "Stateless Service" as Stateless {
  Stateless -> Request : "No Retained Data"
}
rectangle "Stateful Service" as Stateful {
  Stateful --> Request : "Retained Context"
  Stateful -> LocalState : "Depends on Previous State"
}
@enduml
....
--

== 3. Why Stateless Services Scale Easily

When services are stateless:

- Any instance can handle any request.
- Load balancers can distribute traffic evenly.
- Instances can be added or removed without coordination.
- Failures are less disruptive because no session is "stuck" on a node.

This makes stateless design a default goal for horizontally scalable systems.

== 4. Why Stateful Services Are Sometimes Necessary

Some workloads require local or persistent state:

- Databases
- Caches with strong locality
- In-memory processing pipelines
- Long-running workflows

State enables efficiency and correctness but introduces operational complexity.

[.columns]
== 5. Common Examples

[.column]
--
**Stateless**
- REST APIs that read/write from shared databases
- CDN edge servers
- Authentication gateways using tokens

**Stateful**
- Databases and message queues
- Session-based web apps without external session stores
- Real-time game servers with in-memory world state
--

[.column]
--
[plantuml, format=svg, width=100%]
....
@startuml
title Common Examples
left to right direction
rectangle "Stateless Examples" as StatelessExamples {
  StatelessExamples --> "REST APIs" : "Use Shared DB"
  StatelessExamples -> "CDN Edges" : "Cache Content"
}
rectangle "Stateful Examples" as StatefulExamples {
  StatefulExamples --> "Databases" : "Retain Data"
  StatefulExamples -> "Real-Time Apps" : "Maintain Local State"
}
@enduml
....
--

== 6. Managing State in Scalable Systems

Teams often push state into shared systems, even though this can introduce coupling.

Why teams do it:

- **Centralized data control** for consistent updates across services
- **Reduced latency** compared to synchronizing multiple data stores
- **Simplified architecture** vs. complex state replication
- **Cross-service queries** are easier with shared data access

== 6b. Shared Database Risks and Mitigations

Shared databases reduce complexity but increase coupling. Common mitigations:

- **Versioned schemas** and compatibility windows
- **Clear API boundaries** between teams
- **Defined ownership** for data access and change control

[.columns]
== 7. Session State and User Context

[.column]
--
Classic web apps stored session data in memory on a single server. That creates problems:

- Sticky sessions are required
- Failover can lose sessions
- Horizontal scaling becomes harder

Modern alternatives:

- Store sessions in Redis or a database
- Use stateless tokens (JWTs)
--

[.column]
--
[plantuml, format=svg, width=100%]
....
@startuml
title Session State Challenges
left to right direction
rectangle "In-Memory Sessions" as InMemory {
  InMemory --> Server : "Sticky Sessions Required"
  InMemory -> Failure : "Session Loss on Failover"
}
rectangle "Modern Alternatives" as Alternatives {
  Alternatives --> Redis : "Store Sessions"
  Alternatives -> Tokens : "Use JWTs"
}
@enduml
....
--

== 8. Reliability and Failure Modes

**Stateless systems**
- Easier to recover after failures
- Lost instances do not lose critical data

**Stateful systems**
- Must protect data through replication, backups, and recovery procedures
- Require careful failover and consistency planning

State increases both responsibility and risk.

== 9. Tradeoffs and Design Choices

Stateless systems:

- Easier to scale and deploy
- Easier to automate in CI/CD
- Require external state management

Stateful systems:

- Can be faster for local operations
- Reduce network hops for repeated access
- Are harder to scale and recover

The right choice depends on performance requirements, cost, and operational maturity.


[.columns]
== 10. Example Scenario

[.column]
--
**Stateful**: cart stored in server memory.

- Fast access
- Breaks on server failure or scaling
--

[.column]
--
**Stateless**: cart stored in Redis or database.

- Slightly more latency
- Survives scaling and failures
--

== 11. Key Takeaways

- Stateless services scale and recover more easily.
- Stateful services are sometimes unavoidable but require stronger operations.
- The core design question is: **where does state live?**
- The most common pattern is stateless application servers with shared state stores.
- Utilizing shared databases can simplify architecture despite introducing coupling, ensuring data consistency and quick access.
