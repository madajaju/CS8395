= Stateless vs Stateful Services

== 1. Motivation: Why State Matters

Every system needs to remember something:

- Who is logged in
- What items are in a cart
- Where a workflow is in its lifecycle

The architectural question is **where that memory lives**. This choice affects:

- Scalability
- Reliability
- Deployment strategy
- Cost

---

== 2. Core Definitions

**Stateless service**
- Does not retain client-specific data between requests.
- Each request contains all information needed to process it.

**Stateful service**
- Retains data or context across requests.
- Requests depend on prior interaction or local stored state.

In practice, most systems include both, but the distribution of state is a major design decision.

[plantuml]
....
@startuml
  title Core Definitions
  left to right direction
  rectangle "Stateless Service" as Stateless {
    Stateless -> Request : "No Retained Data"
  }
  rectangle "Stateful Service" as Stateful {
    Stateful -> Request : "Retained Context"
    Stateful -> LocalState : "Depends on Previous State"
  }
@enduml
....

---

== 3. Why Stateless Services Scale Easily

When services are stateless:

- Any instance can handle any request.
- Load balancers can distribute traffic evenly.
- Instances can be added or removed without coordination.
- Failures are less disruptive because no session is "stuck" on a node.

This makes stateless design a default goal for horizontally scalable systems.

---

== 4. Why Stateful Services Are Sometimes Necessary

Some workloads require local or persistent state:

- Databases
- Caches with strong locality
- In-memory processing pipelines
- Long-running workflows

State enables efficiency and correctness but introduces operational complexity.

---

== 5. Common Examples

**Stateless**
- REST APIs that read/write from shared databases
- CDN edge servers
- Authentication gateways using tokens

**Stateful**
- Databases and message queues
- Session-based web apps without external session stores
- Real-time game servers with in-memory world state

[plantuml]
....
@startuml
  title Common Examples
  left to right direction
  rectangle "Stateless Examples" as StatelessExamples {
    StatelessExamples -> "REST APIs" : "Use Shared DB"
    StatelessExamples -> "CDN Edges" : "Cache Content"
  }
  rectangle "Stateful Examples" as StatefulExamples {
    StatefulExamples -> "Databases" : "Retain Data"
    StatefulExamples -> "Real-Time Apps" : "Maintain Local State"
  }
@enduml
....

---

== 6. Managing State in Scalable Systems

Teams often push state into shared systems, even though this can introduce coupling. Hereâ€™s why shared databases might be recommended:

- **Centralized Data Control**: Shared databases provide a centralized point for data management, ensuring consistency across services.

- **Reduced Latency for Data Access**: Accessing a shared database can be faster than synchronizing state across multiple data stores.

- **Simplified Architecture**: Utilizing a shared database reduces the need for complex state-management strategies.

- **Support for Cross-Service Queries**: Shared databases enable efficient cross-service data queries, enhancing overall data coherence.

While shared databases can reduce complexities, teams should implement effective strategies, like versioning and clear API boundaries, to mitigate coupling risks.

---

== 7. Session State and User Context

Classic web apps stored session data in memory on a single server. That creates problems:

- Sticky sessions are required
- Failover can lose sessions
- Horizontal scaling becomes harder

Modern alternatives:

- Store sessions in Redis or a database
- Use stateless tokens (JWTs)

[plantuml]
....
@startuml
  title Session State Challenges
  left to right direction
  rectangle "In-Memory Sessions" as InMemory {
    InMemory -> Server : "Sticky Sessions Required"
    InMemory -> Failure : "Session Loss on Failover"
  }
  rectangle "Modern Alternatives" as Alternatives {
    Alternatives -> Redis : "Store Sessions"
    Alternatives -> Tokens : "Use JWTs"
  }
@enduml
....

---

== 8. Reliability and Failure Modes

**Stateless systems**
- Easier to recover after failures
- Lost instances do not lose critical data

**Stateful systems**
- Must protect data through replication, backups, and recovery procedures
- Require careful failover and consistency planning

State increases both responsibility and risk.

---

== 9. Tradeoffs and Design Choices

Stateless systems:

- Easier to scale and deploy
- Easier to automate in CI/CD
- Require external state management

Stateful systems:

- Can be faster for local operations
- Reduce network hops for repeated access
- Are harder to scale and recover

The right choice depends on performance requirements, cost, and operational maturity.

---

== 10. Example Scenario

A shopping cart service can be built in two ways:

1. **Stateful**: cart stored in server memory.
   - Fast access
   - Breaks on server failure or scaling
2. **Stateless**: cart stored in Redis or database.
   - Slightly more latency
   - Survives scaling and failures

Most modern systems choose the stateless approach because it scales better.

---

== 11. Key Takeaways

- Stateless services scale and recover more easily.
- Stateful services are sometimes unavoidable but require stronger operations.
- The core design question is: **where does state live?**
- The most common pattern is stateless application servers with shared state stores.
- Utilizing shared databases can simplify architecture despite introducing coupling, ensuring data consistency and quick access.